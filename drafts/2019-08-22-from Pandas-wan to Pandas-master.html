---
layout: post
title:  "从 Pandas 小白到 Pandas 能手"
date:   2019-08-21 08:36:00
categories: Computer_Science Python Pandas
excerpt: "本文译自 Unit8 数据科学家 Rudolf Höhn 先生的文章 From Pandas-wan to Pandas-master，文章发表在博客平台 Medium 上，文章介绍了 Pandas 的发展现状、内存优化、索引和方法链等内容，作者在文章中给出了许多提升程序运行性能的建议。Unit8 是一家位于瑞士莫尔日，成立于 2017 年的初创公司，致力于利用大数据和人工智能技术解决各行各业问题。2019 年 5 月 21 日，公司加入数字瑞士（digitalswitzerland）组织，该组织包括 150 多家公司、学术和政府机构，其使命是将瑞士打造为全球领先的数字创新中心"
permalink: /from Pandas-wan to Pandas-master/
---

<div class="post-style">

<blockquote>本文译自 Unit8 数据科学家 <a href="https://medium.com/@rudolfhohn">Rudolf Höhn</a> 先生的文章 "<a href="https://medium.com/unit8-machine-learning-publication/from-pandas-wan-to-pandas-master-4860cf0ce442">From Pandas-wan to Pandas-master</a>"，文章发表在博客平台 Medium 上，文章介绍了 Pandas 的发展现状、内存优化、索引和方法链等内容，作者在文章中给出了许多提升程序运行性能的建议。<a href="https://unit8.co/">Unit8</a> 是一家位于瑞士莫尔日，成立于 2017 年的初创公司，致力于利用大数据和人工智能技术解决各行各业问题。2019 年 5 月 21 日，公司加入<a href="https://digitalswitzerland.com/">数字瑞士</a>（digitalswitzerland）组织，该组织包括 150 多家公司、学术和政府机构，其使命是将瑞士打造为全球领先的数字创新中心。</blockquote>

<p>在 Unit8, 我们为客户提供支持，我们利用数据资源构建有影响的高水平的机器学习模型，这些模型是商业用以产生强大影响力的合适工具。在追寻使命的漫漫征途里，我们使用了许多工具，其中之一就是 Python 库: Pandas。</p>

<p>通过这篇文章，你将有望发现一种、两种或更多种新的使用 Pandas 编写代码的方式。</p>

<p>这篇博文介绍 Pandas 的最佳实践，它适用于所有使用 Pandas 的人，无论这种使用是否频繁，它也适用于所有想要使用 Pandas 的人。即便你以前从未使用过 Pandas，现在开始也不迟，你说对吗？</p>

<p>文章将会涉及以下几个方面：</p>

<ul>
    <li>Pandas 的发展现状</li>
    <li>内存优化</li>
    <li>索引</li>
    <li>方法链</li>
    <li>随机给出的一些小建议</li>
</ul>

<p>在你阅读本文时，我推荐你查阅那些你看不懂的函数的帮助信息（docstrings）。做个简单的谷歌搜索以及花上几秒钟阅读 Pandas 文档，将会让你的阅读更加愉快。</p>

<blockquote>译者注：docstrings 是紧跟在 def 或 class 后的第一个字符串，这个字符串通常用来记录函数或类的帮助信息，以函数为例，这些信息可能包括函数的作用、参数的数据类型和含义、返回值的类型和含义以及使用示例等内容，这个字符串存储在对象属性 __doc__ 中，可以使用对象名.__doc__ 查看，此外也可以使用 help 命令查看。</blockquote>

<h1>1 Pandas 的定义与现状</h1>

<blockquote>那什么是 Pandas ?</blockquote>

<p>Pandas 是一个 “开放源代码，使用 BSD 许可证的库，它为 Python 编程语言提供高性能、易用的数据结构和数据分析工具”（摘自 Pandas 网站）。总的来说，它提供了叫做 DataFrame 和 Series 的数据抽象（已不推荐使用 Panel），它管理索引以实现数据的快速存取，它执行分析和转换运算，它甚至能（使用 matplotlib 后端）画图。</p>

<p>截止到本文写作，Pandas 的最新发行版本为 v0.24.2.（译者注：截止到笔者翻译，Pandas 的最新发行版本为 v0.25.0）</p>

<p>是的，Pandas 正走在通往 1.0 版本的道路上，而要到达那里，就不得不改变一点点人们已经习惯的用法。这里有一个非常有趣的演讲：Pandas 核心贡献者 <a href="https://datapythonista.github.io/">Marc Garcia</a> 的 “<a href="https://www.youtube.com/watch?v=hK6o_TDXXN8">走向 Pandas 1.0</a>”。</p>

<p>下一个版本 v0.25 的发行定在 2019 年 7 月（v0.25rc0 已于 7 月 4 日发行），它与 v1.0 有相同的代码库，但在使用即将弃用的方法时会显示警告信息（warning messages）。所以，如果你计划使用 v1.0, 那么当你运行你的 v0.25 代码库时，请务必关注所有的弃用警告（deprecation wranings）。</p>

<p>一句话总结，Pandas v1.0 主要改善了稳定性（例如：时间序列）并且移除了无用的代码库（例如：SparseDataFrame）.</p>

<h1>2 数据</h1>

<p>让我们开始工作吧，我们选择的数据集是（来自 Kaggle）的玩具数据集 “1985 到 2016 年国家自杀率”。这个数据集虽然简单，但对于你上手 Pandas 已经足够了。</p>

<p>在深入研究代码之前，如果你想重现结果，还需要执行这个简短的数据预处理过程，以确保你拥有正确的列名和列类型。</p>

</div>

<div class="code-style">

{% highlight Python %}

import pandas as pd
import numpy as np
import os


# to download https://www.kaggle.com/russellyates88/suicide-rates-overview-1985-to-2016
data_path = 'path/to/folder/'

df = (pd.read_csv(filepath_or_buffer=os.path.join(data_path, 'master.csv'))
      .rename(columns={'suicides/100k pop' : 'suicides_per_100k',
                       ' gdp_for_year ($) ' : 'gdp_year',
                       'gdp_per_capita ($)' : 'gdp_capita',
                       'country-year' : 'country_year'})
      .assign(gdp_year=lambda _df: _df['gdp_year'].str.replace(',','').astype(np.int64))
     )

{% endhighlight %}

</div>

<div class="post-style">

<blockquote>小建议：如果你要读入一个大文件，请在 read_scv() 中使用参数 chunksize=N，此时函数将返回一个输出为 DataFrame 对象的迭代器</blockquote>

<p>下面是数据集的部分展示：</p>

<div class="post-text-center">
    <table>
      <thead>
        <tr>
            <th>country</th>
            <th>year</th>
            <th>sex</th>
            <th>age</th>
            <th>suicides_no</th>
            <th>population</th>
            <th>suicides_per_100k</th>
            <th>country_year</th>
            <th>HDI for year</th>
            <th>gdp_year</th>
            <th>gdp_capita</th>
            <th>generation</th>
        </tr>
      </thead>
      <tbody>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>male</td>
              <td>15-24 years</td>
              <td>21</td>
              <td>312900</td>
              <td>6.71</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>Generation X</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>male</td>
              <td>35-54 years</td>
              <td>16</td>
              <td>308000</td>
              <td>5.19</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>Silent</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>female</td>
              <td>15-24 years</td>
              <td>14</td>
              <td>289700</td>
              <td>4.83</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>Generation X</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>male</td>
              <td>75+ years</td>
              <td>1</td>
              <td>21800</td>
              <td>4.59</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>G.I. Generation</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>male</td>
              <td>25-34 years</td>
              <td>9</td>
              <td>274300</td>
              <td>3.28</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>Boomers</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>female</td>
              <td>75+ years</td>
              <td>1</td>
              <td>35600</td>
              <td>2.81</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>G.I. Generation</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>female</td>
              <td>35-54 years</td>
              <td>6</td>
              <td>278800</td>
              <td>2.15</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>Silent</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>female</td>
              <td>25-34 years</td>
              <td>4</td>
              <td>257200</td>
              <td>1.56</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>Boomers</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>male</td>
              <td>55-74 years</td>
              <td>1</td>
              <td>137500</td>
              <td>0.73</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>G.I. Generation</td>
          </tr>
          <tr>
              <td>Albania</td>
              <td>1987</td>
              <td>female</td>
              <td>5-14 years</td>
              <td>0</td>
              <td>311000</td>
              <td>0.0</td>
              <td>Albania1987</td>
              <td></td>
              <td>2156624900</td>
              <td>796</td>
              <td>Generation X</td>
          </tr>
      </tbody>
    </table>
</div>

</div>

<div class="code-style">

{% highlight Python %}

>>> df.columns
Index(['country', 'year', 'sex', 'age', 'suicides_no', 'population',
       'suicides_per_100k', 'country_year', 'HDI for year', 'gdp_year',
       'gdp_capita', 'generation'],
      dtype='object')

{% endhighlight %}

</div>

<div class="post-style">

<p class="post-text-noindent">这里有 101 个国家，年份从 1985 到 2016，有两种性别，六个世代以及六个年龄组。使用一些简单而有用的方法，我们就可以获得这些信息。</p>

<ul>
    <li>unique() 和 nunique() 用来获取去除了重复值的列（或去重列中的元素数目）</li>
</ul>

</div>

<div class="code-style">

{% highlight Python %}

>>> df['generation'].unique()
array(['Generation X', 'Silent', 'G.I. Generation', 'Boomers',
       'Millenials', 'Generation Z'], dtype=object)
>>> df['country'].nunique()
101

{% endhighlight %}

</div>

<div class="post-style">

<ul>
    <li>describe() 为每一个数值列输出不同的统计数字（例如：最小值，最大值，均值，个数），如果设置参数 'include=all' 则还会显示每个对象列去重后的元素个数以及顶部元素（即频率最高的元素）的个数。</li>
</ul>

<div class="post-text-center">
    <table>
      <thead>
        <tr>
            <th></th>
            <th>year</th>
            <th>suicides_no</th>
            <th>population</th>
            <th>suicides_per_100k</th>
            <th>HDI for year</th>
            <th>gdp_year</th>
            <th>gdp_capita</th>
        </tr>
      </thead>
      <tbody>
          <tr>
              <td>count</td>
              <td>27820.0</td>
              <td>27820.0</td>
              <td>27820.0</td>
              <td>27820.0</td>
              <td>8364.0</td>
              <td>27820.0</td>
              <td>27820.0</td>
          </tr>
          <tr>
              <td>mean</td>
              <td>2001.2583752695903</td>
              <td>242.57440690150972</td>
              <td>1844793.6173975556</td>
              <td>12.816097411933864</td>
              <td>0.7766011477761837</td>
              <td>445580969025.7266</td>
              <td>16866.464414090584</td>
          </tr>
          <tr>
              <td>std</td>
              <td>8.46905502444141</td>
              <td>902.0479168336403</td>
              <td>3911779.441756363</td>
              <td>18.961511014503195</td>
              <td>0.09336670859029964</td>
              <td>1453609985940.912</td>
              <td>18887.576472205572</td>
          </tr>
          <tr>
              <td>min</td>
              <td>1985.0</td>
              <td>0.0</td>
              <td>278.0</td>
              <td>0.0</td>
              <td>0.483</td>
              <td>46919625.0</td>
              <td>251.0</td>
          </tr>
          <tr>
              <td>25%</td>
              <td>1995.0</td>
              <td>3.0</td>
              <td>97498.5</td>
              <td>0.92</td>
              <td>0.713</td>
              <td>8985352832.0</td>
              <td>3447.0</td>
          </tr>
          <tr>
              <td>50%</td>
              <td>2002.0</td>
              <td>25.0</td>
              <td>430150.0</td>
              <td>5.99</td>
              <td>0.779</td>
              <td>48114688201.0</td>
              <td>9372.0</td>
          </tr>
          <tr>
              <td>75%</td>
              <td>2008.0</td>
              <td>131.0</td>
              <td>1486143.25</td>
              <td>16.62</td>
              <td>0.855</td>
              <td>260202429150.0</td>
              <td>24874.0</td>
          </tr>
          <tr>
              <td>max</td>
              <td>2016.0</td>
              <td>22338.0</td>
              <td>43805214.0</td>
              <td>224.97</td>
              <td>0.9440000000000001</td>
              <td>18120714000000.0</td>
              <td>126352.0</td>
          </tr>
      </tbody>
    </table>
</div>

<ul>
    <li>head() 和 tail() 用来显示数据框的一小部分</li>
</ul>

<p class="post-text-noindent">使用这些方法，你将很快了解你正在分析的表格文件。</p>

<h1>3 内存优化</h1>

<p>理解数据并且为数据框的每一列选择合适的数据类型，是处理数据前的一个重要步骤。</p>

<p>在内部，Pandas 将数据框存储为不同类型的 numpy 数组（例如：一个 float64 矩阵，一个 int32 矩阵）。</p>

<p>下面是大幅度降低内存消耗的两种方法：</p>

</div>

<div class="code-style">

{% highlight Python %}

import pandas as pd


def mem_usage(df: pd.DataFrame) -> str:
    """This method styles the memory usage of a DataFrame to be readable as MB.
    Parameters
    ----------
    df: pd.DataFrame
        Data frame to measure.
    Returns
    -------
    str
        Complete memory usage as a string formatted for MB.
    """
    return f'{df.memory_usage(deep=True).sum() / 1024 ** 2 : 3.2f} MB'


def convert_df(df: pd.DataFrame, deep_copy: bool = True) -> pd.DataFrame:
    """Automatically converts columns that are worth stored as
    ``categorical`` dtype.
    Parameters
    ----------
    df: pd.DataFrame
        Data frame to convert.
    deep_copy: bool
        Whether or not to perform a deep copy of the original data frame.
    Returns
    -------
    pd.DataFrame
        Optimized copy of the input data frame.
    """
    return df.copy(deep=deep_copy).astype({
        col: 'category' for col in df.columns
        if df[col].nunique() / df[col].shape[0] < 0.5})

{% endhighlight %}

</div>

<div class="post-style">

<p class="post-text-noindent">memory_usage() 是 Pandas 自带的用来分析数据框内存消耗的方法。上面代码中，deep=True 用来确保将真实的系统消耗考虑在内。</p>

<p>理解列的类型是重要的，作如下两件简单的事情，你就可以减少 90 % 的内存占用：</p>

<ul>
    <li>搞清楚你的数据框正在使用的类型</li>
    <li>搞清楚存在哪些可用类型能够降低你的数据框的内存占用（例如：如果对取值范围在 0 到 59 且只有 1 位小数的 price 列使用 float64，就可能造成不必要的开销）</li>
</ul>

<p>除了你可能正在使用的减少数值类型大小的方式（用 int32 代替 int64），Pandas 还自带有一种分类（category）类型来减少内存占用。</p>

<blockquote>如果你是一名 R 开发者，你会发现它和 factor 类型是一致的。</blockquote>

<p class="post-text-noindent">这种类别类型使用索引替代重复值，而将真实值存储在其他地方。一个教科书式的例子便是国家，如果要多次存储相同的字符串 “瑞士” 或者 “波兰”，为什么不简洁地用 0 和 1 替代它们并存储一个字典呢？</p>

</div>

<div class="code-style">

{% highlight Python %}

categorical_dict = {0: 'Switzerland', 1: 'Poland'}

{% endhighlight %}

</div>

<div class="post-style">

<p class="post-text-noindent">当添加所有这些方法让类型得以使用并保证能够显示国家名称时，Pandas 实际上做着几乎相同的事情。</p>

<p>回到我们的方法 convert_df()，如果去重后元素个数小于原来元素个数的 50 %，该方法会把列类型自动转换为 category. 虽然这个数字可以任意选取，但由于数据框类型的转换意味着在 numpy 数组中移动数据，因此数字的选取应确保这种转换是值得的（译者注：保证转换操作本身带来的开销，小于不转换相较于转换所增加的额外开销）。</p>

<p>让我们看看我们的数据发生了什么</p>

</div>

<div class="code-style">

{% highlight Python %}

>>> mem_usage(df)
10.28 MB
>>> mem_usage(df.set_index(['country', 'year', 'sex', 'age']))
5.00 MB
>>> mem_usage(convert_df(df))
1.40 MB
>>> mem_usage(convert_df(df.set_index(['country', 'year', 'sex', 'age'])))
1.40 MB

{% endhighlight %}

</div>

<div class="post-style">

<p class="post-text-noindent">通过使用我们 “机智的” 转换器，数据框的内存占用减少了几乎 10 倍（严格来说是 7.34 倍）。</p>

<h1>4 索引</h1>

<p></p>

</div>